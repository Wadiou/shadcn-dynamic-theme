#!/usr/bin/env node
const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

// --- Bootstrapping: Auto-install dependencies ---
const REQUIRED_PACKAGES = ["commander", "prompts", "picocolors", "postcss"];

function installDependencies() {
	console.log("Checking dependencies...");
	const missing = [];
	for (const pkg of REQUIRED_PACKAGES) {
		try {
			require.resolve(pkg);
		} catch (e) {
			missing.push(pkg);
		}
	}

	if (missing.length > 0) {
		console.log(
			`Installing missing dependencies: ${missing.join(", ")}...`,
		);
		try {
			// Install to a temporary location or just npm install --no-save to current node_modules
			// using --no-save to avoid modifying the user's package.json if it exists
			execSync(`npm install --no-save ${missing.join(" ")}`, {
				stdio: "inherit",
			});
			console.log("Dependencies installed successfully.\n");
		} catch (e) {
			console.error("Failed to install dependencies automatically.");
			console.error(
				"Please run: npm install commander prompts picocolors",
			);
			process.exit(1);
		}
	}
}

installDependencies();

// --- Import Dependencies ---
const { Command } = require("commander");
const prompts = require("prompts");
const pc = require("picocolors");
const postcss = require("postcss");

// --- Constants ---
const MARKER_START = "/* @shadcn-dynamic-theme-start */";
const MARKER_END = "/* @shadcn-dynamic-theme-end */";
const WARNING_MSG = `
  /* -------------------------------------------------------------------------- */
  /*                         DO NOT EDIT THIS SECTION                          */
  /*                                                                          */
  /*  This section is auto-generated by scripts/generate-themes.js.           */
  /*  Any manual changes will be overwritten.                                 */
  /* -------------------------------------------------------------------------- */
`;

// --- Config Manager ---
class ConfigManager {
	static findProjectConfig() {
		try {
			// Check for components.json in current directory
			const componentsJsonPath = path.resolve("components.json");
			if (fs.existsSync(componentsJsonPath)) {
				const componentsConfig = JSON.parse(
					fs.readFileSync(componentsJsonPath, "utf-8"),
				);
				// Support both v3 and v4 structure
				const cssPath =
					componentsConfig.tailwind?.css ||
					componentsConfig.css ||
					componentsConfig.globalCss;
				if (cssPath) {
					return { cssPath: path.resolve(cssPath) };
				}
			}
		} catch (e) {
			console.warn(pc.yellow("Warning: Could not read components.json."));
		}
		return null;
	}

	static loadThemes() {
		const themesPath = path.join(__dirname, "themes.json");
		if (!fs.existsSync(themesPath)) {
			console.error(
				pc.red(`Error: themes.json not found at ${themesPath}`),
			);
			process.exit(1);
		}
		return JSON.parse(fs.readFileSync(themesPath, "utf-8"));
	}
}

// --- Theme Generator ---
class ThemeGenerator {
	constructor(themes, cssPath) {
		this.themes = themes;
		this.cssPath = cssPath;
	}

	// Generates the CSS block
	generateBlock(defaultTheme, auxThemes) {
		let css = `${MARKER_START}\n${WARNING_MSG}\n`;

		// 1. Write Default Theme to :root and .dark
		css += `
:root {
${defaultTheme.css.light
	.split("\n")
	.map((l) => "  " + l)
	.join("\n")}
}
.dark {
${defaultTheme.css.dark
	.split("\n")
	.map((l) => "  " + l)
	.join("\n")}
}
`;

		// 2. Write Auxiliary Themes to .theme-{name}
		auxThemes.forEach((theme) => {
			// Skip if it's the same as default (though user usually wouldn't select it twice if logic is correct)
			if (theme.name === defaultTheme.name) return;

			css += `
.theme-${theme.name} {
${theme.css.light
	.split("\n")
	.map((l) => "  " + l)
	.join("\n")}
}
.dark.theme-${theme.name} {
${theme.css.dark
	.split("\n")
	.map((l) => "  " + l)
	.join("\n")}
}
`;
		});

		css += `${MARKER_END}\n`;
		return css;
	}

	// Robustly remove existing :root and .dark blocks to avoid redundancy/conflicts
	cleanExistingThemeVars(cssContent) {
		try {
			// Define a plugin to remove top-level :root and .dark
			const removeThemeVarsPlugin = () => {
				return {
					postcssPlugin: "remove-theme-vars",
					Once(root) {
						root.walkRules((rule) => {
							// Check if the rule is strictly top-level (parent is root)
							// AND matches our target selectors
							if (rule.parent.type === "root") {
								if (
									rule.selector === ":root" ||
									rule.selector === ".dark"
								) {
									rule.remove();
								}
							}
						});
					},
				};
			};
			removeThemeVarsPlugin.postcss = true;

			// Process synchronously
			const result = postcss([removeThemeVarsPlugin()]).process(
				cssContent,
				{
					from: undefined,
				},
			);

			// Use the result css
			// Note: PostCSS might reformat slightly, but that's usually acceptable or even desired.
			return result.css;
		} catch (e) {
			console.error(pc.red("Error processing CSS with PostCSS:"), e);
			// Fallback to original content if PostCSS fails (safest)
			return cssContent;
		}
	}

	generate(defaultThemeName, selectedThemeNames) {
		if (!fs.existsSync(this.cssPath)) {
			console.error(
				pc.red(`Error: CSS file not found at ${this.cssPath}`),
			);
			return;
		}

		let cssContent = fs.readFileSync(this.cssPath, "utf-8");

		// Identify themes
		const defaultTheme = this.themes.find(
			(t) => t.name === defaultThemeName,
		);
		if (!defaultTheme) {
			console.error(
				pc.red(`Error: Default theme '${defaultThemeName}' not found.`),
			);
			return;
		}

		// Filter aux themes
		let auxThemes = [];
		if (selectedThemeNames) {
			auxThemes = this.themes.filter(
				(t) =>
					selectedThemeNames.includes(t.name) &&
					t.name !== defaultThemeName,
			);
		} else {
			// If explicit null passed (CLI flag?), careful.
			// Usually interactive returns [] if none.
			auxThemes = [];
		}

		const newCssBlock = this.generateBlock(defaultTheme, auxThemes);

		// 1. Remove existing managed block
		const startIndex = cssContent.indexOf(MARKER_START);
		const endIndex = cssContent.indexOf(MARKER_END);

		if (startIndex !== -1 && endIndex !== -1) {
			console.log(pc.blue(`ℹ Removing old managed theme block...`));
			const before = cssContent.substring(0, startIndex);
			const after = cssContent.substring(endIndex + MARKER_END.length);
			cssContent = before + after;
		}

		// 2. Aggressive Cleanup of unmanaged :root / .dark
		// We do this AFTER removing our block to avoid double cleaning if our block had them.
		// But our block has markers, so it's fine.
		// We need to be careful not to leave "/* replaced */" comments everywhere if we run multiple times.
		// Actually, if we just stripped our block, the rest should be "user code".
		// User wants us to delete :root/.dark from user code too.
		console.log(
			pc.blue(`ℹ Cleaning up existing :root and .dark definitions...`),
		);
		cssContent = this.cleanExistingThemeVars(cssContent);

		// 3. Append new block
		// We append to the end, or after @layer base if we can find it, to be nice.
		// But standard behavior: Just append.
		console.log(
			pc.blue(
				`ℹ Writing new default theme ('${defaultTheme.name}') and ${auxThemes.length} auxiliary themes...`,
			),
		);
		cssContent += "\n" + newCssBlock;

		// Creating backup
		try {
			fs.writeFileSync(
				`${this.cssPath}.bak`,
				fs.readFileSync(this.cssPath),
			);
			// console.log(pc.dim(`  Backup created.`));
		} catch (e) {}

		// Writing new content
		fs.writeFileSync(this.cssPath, cssContent);
		console.log(pc.green(`✔ CSS updated successfully!`));
	}
}

// --- Interaction Manager ---
class InteractionManager {
	static async promptSelection(allThemes) {
		const choices = allThemes.map((t) => ({
			title: t.name,
			value: t.name,
		}));

		// 1. Select Default
		const defaultResponse = await prompts({
			type: "select",
			name: "defaultTheme",
			message: "Select your DEFAULT theme (applied to :root):",
			choices,
			initial: 0,
		});

		if (!defaultResponse.defaultTheme) return null;

		// 2. Select Additional
		// Filter out the default from options
		const remainingChoices = choices.filter(
			(c) => c.value !== defaultResponse.defaultTheme,
		);

		let auxThemes = [];
		if (remainingChoices.length > 0) {
			const auxResponse = await prompts({
				type: "multiselect",
				name: "themes",
				message: "Select ADDITIONAL themes (optional, for switching):",
				choices: remainingChoices.map((c) => ({
					...c,
					selected: false,
				})),
				hint: "- Space to select. ⏎ Return to submit",
				instructions: false,
			});
			auxThemes = auxResponse.themes || [];
		}

		return {
			defaultTheme: defaultResponse.defaultTheme,
			auxThemes,
		};
	}
}

// --- Themes TS Manager ---
class ThemesTsManager {
	constructor(themesPath) {
		this.themesPath = themesPath;
	}

	extractPrimaryColor(cssContent) {
		let primaryColor;
		try {
			const root = postcss.parse(cssContent);
			root.walkDecls((decl) => {
				if (decl.prop === "--primary") {
					primaryColor = decl.value;
				}
			});
		} catch (e) {
			console.error("Error parsing CSS for extraction:", e);
		}
		return primaryColor;
	}

	generateTsContent(allThemes, defaultThemeName, auxThemeNames) {
		const selectedThemeNames = [defaultThemeName, ...auxThemeNames];

		// Map themes to the structure required by lib/themes.ts
		const availableThemesStruct = allThemes.map((t) => ({
			name: t.name,
			color: this.extractPrimaryColor(t.css.light),
			darkColor: this.extractPrimaryColor(t.css.dark),
		}));

		const selectedThemesStruct = availableThemesStruct.filter((t) =>
			selectedThemeNames.includes(t.name),
		);

		const defaultThemeStruct = availableThemesStruct.find(
			(t) => t.name === defaultThemeName,
		);

		return `
export const AVAILABLE_THEMES = ${JSON.stringify(availableThemesStruct, null, 4)} as const;

export const THEMES = ${JSON.stringify(selectedThemesStruct, null, 4)} as const;

export const SUPPORTED_THEMES = THEMES.map((theme) => theme.name);
export type ColorTheme = (typeof SUPPORTED_THEMES)[number];

export const DEFAULT_THEME: ColorTheme = "${defaultThemeName}";
export const DEFAULT_THEME_COLOR = { color: "${defaultThemeStruct.color}", darkColor: "${defaultThemeStruct.darkColor}" };
`;
	}

	update(allThemes, defaultThemeName, auxThemeNames) {
		const tsContent = this.generateTsContent(
			allThemes,
			defaultThemeName,
			auxThemeNames,
		);
		const MARKER_START = "// @shadcn-dynamic-theme-start";
		const MARKER_END = "// @shadcn-dynamic-theme-end";

		let content = "";
		if (fs.existsSync(this.themesPath)) {
			content = fs.readFileSync(this.themesPath, "utf-8");
		} else {
			// If file doesn't exist, create a basic structure with markers
			content = `${MARKER_START}\n${MARKER_END}\n`;
		}

		console.log(pc.blue(`ℹ Updating lib/themes.ts...`));

		const regex = new RegExp(`${MARKER_START}[\\s\\S]*?${MARKER_END}`, "m");
		const newBlock = `${MARKER_START}\n${tsContent}\n${MARKER_END}`;

		if (regex.test(content)) {
			content = content.replace(regex, newBlock);
		} else {
			// Append if markers missing
			content += `\n${newBlock}`;
		}

		fs.writeFileSync(this.themesPath, content, "utf-8");
		console.log(pc.green(`✔ lib/themes.ts updated successfully!`));
	}
}

// --- Main ---
async function main() {
	const program = new Command();
	const allThemes = ConfigManager.loadThemes();
	const projectConfig = ConfigManager.findProjectConfig();

	if (!projectConfig) {
		console.error(
			pc.red(
				"Error: Could not find components.json. Run this in your Shadcn project root.",
			),
		);
		process.exit(1);
	}

	const themeNames = allThemes.map((t) => t.name).join(", ");

	program
		.name("generate-themes")
		.description(
			`Generates CSS variables for Shadcn Dynamic Themes.
			
Available themes:
${themeNames
	.split(", ")
	.map((t) => `  - ${t}`)
	.join("\n")}`,
		)
		.option(
			"-d, --default <name>",
			`Default theme name (applied to :root and .dark). Example: --default=blue`,
		)
		.option(
			"-t, --themes <names>",
			`Comma-separated list of additional themes. Example: --themes=orange,red`,
		)
		.action(async (options) => {
			let defaultThemeName = options.default;
			let auxThemeNames = options.themes
				? options.themes.split(",").map((s) => s.trim())
				: null;

			if (!defaultThemeName) {
				// Interactive
				console.log(pc.cyan(`\nShadcn Dynamic Theme Generator\n`));
				const selection =
					await InteractionManager.promptSelection(allThemes);
				if (!selection) {
					console.log(pc.yellow("Cancelled."));
					process.exit(0);
				}
				defaultThemeName = selection.defaultTheme;
				auxThemeNames = selection.auxThemes;
			}

			if (!auxThemeNames) auxThemeNames = [];

			// Validation
			const validNames = allThemes.map((t) => t.name);
			if (!validNames.includes(defaultThemeName)) {
				console.error(
					pc.red(
						`Error: Invalid default theme '${defaultThemeName}'. Available: ${validNames.join(", ")}`,
					),
				);
				process.exit(1);
			}
			const invalid = auxThemeNames.filter(
				(name) => !validNames.includes(name),
			);
			if (invalid.length > 0) {
				console.error(
					pc.red(
						`Error: Invalid themes specified: ${invalid.join(", ")}`,
					),
				);
				process.exit(1);
			}

			// 1. Update CSS
			const generator = new ThemeGenerator(
				allThemes,
				projectConfig.cssPath,
			);
			generator.generate(defaultThemeName, auxThemeNames);

			// 2. Update themes.ts
			// Assume it is in lib/themes.ts relative to root
			const themesTsPath = path.resolve("lib/themes.ts");
			const tsManager = new ThemesTsManager(themesTsPath);
			tsManager.update(allThemes, defaultThemeName, auxThemeNames);
		});

	program.parse();
}

main().catch((err) => {
	console.error(pc.red("Unexpected error:"), err);
	process.exit(1);
});
